{
    "docs": [
        {
            "location": "/", 
            "text": "Python for IBM Watson IoT Platform\n\n\nPython module for interacting with the \nIBM Watson IoT Platform\n.\n\n\n\n\nPython 3.6\n\n\nPython 2.7\n\n\n\n\nNote: Support for MQTT with TLS requires at least Python v2.7.9 or v3.4, and openssl v1.0.1\n\n\nDependencies\n\n\n\n\npaho-mqtt\n\n\niso8601\n\n\npytz\n\n\nrequests\n\n\nrequests_toolbelt\n\n\ndicttoxml\n\n\nxmltodict\n\n\n\n\nInstallation\n\n\nInstall the latest version of the library with pip\n\n\n# pip install ibmiotf\n\n\n\n\nUninstall\n\n\nUninstalling the module is simple.\n\n\n# pip uninstall ibmiotf\n\n\n\n\nDocumentation\n\n\nDocumentation is generated using \npydoc-markdown\n: http://ibm-watson-iot.github.io/iot-python/\n\n\nPlease note the documentation is very much a work in progress at the moment, and is being addressed under \nIssue #112\n.  Additional documentation for the library is available in Bluemix, but it's a little out of date in places:\n\n\n\n\nApplication Developers\n\n\nDevice Developers\n\n\n\n\nSupported Features\n\n\n\n\nDevice Connectivity\n: Connect your device(s) to Watson IoT Platform with ease using this library\n\n\nGateway Connectivity\n: Connect your gateway(s) to Watson IoT Platform with ease using this library\n\n\nApplication connectivity\n: Connect your application(s) to Watson IoT Platform with ease using this library\n\n\nWatson IoT API\n: Support for the interacting with the Watson IoT Platform through REST APIs\n\n\nSSL/TLS\n: By default, this library connects your devices, gateways and applications securely to Watson IoT Platform registered service. Ports \n8883\n (default) and \n443\n support secure connections using TLS with the MQTT and HTTP protocol. Support for MQTT with TLS requires at least Python v2.7.9 or v3.4, and openssl v1.0.1\n\n\nDevice Management for Device\n: Connects your device(s) as managed device(s) to Watson IoT Platform.\n\n\nDevice Management for Gateway\n: Connects your gateway(s) as managed device(s) to Watson IoT Platform.\n\n\nDevice Management Extensions\n: Provides support for custom device management actions.\n\n\nScalable Applications\n: Supports load balancing of MQTT subscriptions over multiple application instances.\n\n\nAuto Reconnect\n: All clients support automatic reconnect to the Platform in the event of a network interruption.\n\n\nEvent/Command publish\n: Offers a pure HTTP client supporting messaging over HTTP in addition to the full features client that utilizes HTTP and MQTT technologies as appropriate \n\n\nData Format Support\n: JSON, XML, \n user-defined.\n\n\n\n\nUnsupported Features\n\n\n\n\nClient side Certificate based authentication\n: \nClient side Certificate based authentication\nn\n\n\nWebsockets\n: Support device/gateway/application connectivity to Watson IoT Platform using WebSocket", 
            "title": "Home"
        }, 
        {
            "location": "/#python-for-ibm-watson-iot-platform", 
            "text": "Python module for interacting with the  IBM Watson IoT Platform .   Python 3.6  Python 2.7   Note: Support for MQTT with TLS requires at least Python v2.7.9 or v3.4, and openssl v1.0.1", 
            "title": "Python for IBM Watson IoT Platform"
        }, 
        {
            "location": "/#dependencies", 
            "text": "paho-mqtt  iso8601  pytz  requests  requests_toolbelt  dicttoxml  xmltodict", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#installation", 
            "text": "Install the latest version of the library with pip  # pip install ibmiotf", 
            "title": "Installation"
        }, 
        {
            "location": "/#uninstall", 
            "text": "Uninstalling the module is simple.  # pip uninstall ibmiotf", 
            "title": "Uninstall"
        }, 
        {
            "location": "/#documentation", 
            "text": "Documentation is generated using  pydoc-markdown : http://ibm-watson-iot.github.io/iot-python/  Please note the documentation is very much a work in progress at the moment, and is being addressed under  Issue #112 .  Additional documentation for the library is available in Bluemix, but it's a little out of date in places:   Application Developers  Device Developers", 
            "title": "Documentation"
        }, 
        {
            "location": "/#supported-features", 
            "text": "Device Connectivity : Connect your device(s) to Watson IoT Platform with ease using this library  Gateway Connectivity : Connect your gateway(s) to Watson IoT Platform with ease using this library  Application connectivity : Connect your application(s) to Watson IoT Platform with ease using this library  Watson IoT API : Support for the interacting with the Watson IoT Platform through REST APIs  SSL/TLS : By default, this library connects your devices, gateways and applications securely to Watson IoT Platform registered service. Ports  8883  (default) and  443  support secure connections using TLS with the MQTT and HTTP protocol. Support for MQTT with TLS requires at least Python v2.7.9 or v3.4, and openssl v1.0.1  Device Management for Device : Connects your device(s) as managed device(s) to Watson IoT Platform.  Device Management for Gateway : Connects your gateway(s) as managed device(s) to Watson IoT Platform.  Device Management Extensions : Provides support for custom device management actions.  Scalable Applications : Supports load balancing of MQTT subscriptions over multiple application instances.  Auto Reconnect : All clients support automatic reconnect to the Platform in the event of a network interruption.  Event/Command publish : Offers a pure HTTP client supporting messaging over HTTP in addition to the full features client that utilizes HTTP and MQTT technologies as appropriate   Data Format Support : JSON, XML,   user-defined.", 
            "title": "Supported Features"
        }, 
        {
            "location": "/#unsupported-features", 
            "text": "Client side Certificate based authentication :  Client side Certificate based authentication n  Websockets : Support device/gateway/application connectivity to Watson IoT Platform using WebSocket", 
            "title": "Unsupported Features"
        }, 
        {
            "location": "/docs/abstractClient/", 
            "text": "AbstractClient\n\n\n\nAbstractClient(self, domain, organization, clientId, username, password, port=8883, logHandlers=None, cleanSession='true', transport='tcp')\n\n\n\n\nThe underlying client object utilised for Platform connectivity over MQTT\nin devices, gateways, and applications.\n\n\nParameters\n\n\n\n\ndomain (string)\n: Domain denoting the instance of IBM Watson IoT Platform to connect to\n\n\norganization (string)\n: IBM Watson IoT Platform organization ID to connect to\n\n\nclientId (string)\n: MQTT clientId for the underlying Paho client\n\n\nusername (string)\n: MQTT username for the underlying Paho client\n\n\npassword (string)\n: MQTT password for the underlying Paho client\n\n\nport (int)\n: MQTT port for the underlying Paho client to connect using.  Defaults to \n8883\n\n\nlogHandlers (list\n)\n: Log handlers to configure.  Defaults to \nNone\n,\n    which will result in a default log handler being created.\n\n\ncleanSession (string)\n: Defaults to \ntrue\n.  Although this is a true|false parameter,\n    it is being handled as a string for some reason\n\n\ntransport (string)\n: Defaults to \ntcp\n\n\n\n\nAttributes\n\n\n\n\nclient (paho.mqtt.client.Client)\n: Built-in Paho MQTT client handling connectivity for the client.\n\n\nlogger (logging.logger)\n: Client logger.\n\n\n\n\nsetMessageEncoderModule\n\n\n\nAbstractClient.setMessageEncoderModule(self, messageFormat, module)\n\n\n\n\nSet a Python module as the encoder/decoder for a specified message format.\n\n\nArguments\n\n\n\n\nmessageFormat (string)\n: The message format to retreive the encoder for\n\n\nmodule (module)\n: The Python module to set as the encoder/decoder for \nmessageFormat\n\n\n\n\nstats\n\n\n\nAbstractClient.stats(self)\n\n\n\n\nI think we killed the use of this and this is dead code\n\n\nTODO: clean all this up .. should we really be tracking these stats within the client itself in the first place?\n\n\nsetKeepAliveInterval\n\n\n\nAbstractClient.setKeepAliveInterval(self, newKeepAliveInterval)\n\n\n\n\nReconfigure the keepalive value for any subsequent MQTT connection made\nby the client.  This does not affect the keep alive setting of any\nexisting connection.  Traffic generated by keep alive is minimal, but\nalso billable as part of your data transfer to/from the Platform.\n\n\nProperties\n\n\nnewKeepAliveInterval (int): Number of seconds for the new keepalive interval\n\n\ngetKeepAliveInterval\n\n\n\nAbstractClient.getKeepAliveInterval(self)\n\n\n\n\nGet the current setting for keepalive.  Note: This is not necessarily the\nvalue used by the current active connection, as any changes to this value\nare only applied when a new connection to the Platfrom is established\n\n\nReturns\n\n\nint\n: Number of seconds the keepalive interval is set to\n\n\ndisconnect\n\n\n\nAbstractClient.disconnect(self)\n\n\n\n\nDisconnect the client from IBM Watson IoT Platform\n\n\nconnect\n\n\n\nAbstractClient.connect(self)\n\n\n\n\nConnect the client to IBM Watson IoT Platform using the underlying Paho MQTT client\n\n\nRaises\n\n\n\n\nConnectionException\n: If there is a problem establishing the connection.\n\n\n\n\ngetMessageEncoderModule\n\n\n\nAbstractClient.getMessageEncoderModule(self, messageFormat)\n\n\n\n\nGet the Python module that is currently defined as the encoder/decoder for a specified message format.\n\n\nArguments\n\n\n\n\nmessageFormat (string)\n: The message format to retrieve the encoder for\n\n\n\n\nReturns\n\n\nBoolean\n: The python module, or \nNone\n if there is no codec defined for the \nmessageFormat", 
            "title": "AbstractClient"
        }, 
        {
            "location": "/docs/httpAbstractClient/", 
            "text": "HttpAbstractClient\n\n\n\nHttpAbstractClient(self, clientId, logHandlers=None)\n\n\n\n\nThe underlying client object utilised for Platform connectivity\nover HTPP in devices, gateways, and applications.\n\n\nRestricted to HTTP only.  Unless for some technical reason\nyou are unable to use the full MQTT-enable client there really\nis no need to use this alternative feature-limited client as\ninstalling this library means you already have access to the\nrich MQTT/HTTP client implementation.\n\n\nThe HTTP client supports four content-types for posted events:\n\n\n\n\napplication/xml\n: for events/commands using message format \nxml\n\n\ntext/plain; charset=utf-8\n: for events/commands using message format \nplain\n\n\napplication/octet-stream\n: for events/commands using message format \nbin\n\n\napplication/json\n: the default for all other message formats.\n\n\n\n\nsetMessageEncoderModule\n\n\n\nHttpAbstractClient.setMessageEncoderModule(self, messageFormat, module)\n\n\n\n\nSet a Python module as the encoder/decoder for a specified message format.\n\n\nArguments\n\n\n\n\nmessageFormat (string)\n: The message format to retreive the encoder for\n\n\nmodule (module)\n: The Python module to set as the encoder/decoder for \nmessageFormat\n\n\n\n\ngetMessageEncoderModule\n\n\n\nHttpAbstractClient.getMessageEncoderModule(self, messageFormat)\n\n\n\n\nGet the Python module that is currently defined as the encoder/decoder for a specified message format.\n\n\nArguments\n\n\n\n\nmessageFormat (string)\n: The message format to retrieve the encoder for\n\n\n\n\nReturns\n\n\nBoolean\n: The python module, or \nNone\n if there is no codec defined for the \nmessageFormat\n\n\nconnect\n\n\n\nHttpAbstractClient.connect(self)\n\n\n\n\nConnect is a no-op with HTTP-only client, but the presence of this method makes it easy\nto switch between using HTTP \n MQTT client implementation\n\n\ndisconnect\n\n\n\nHttpAbstractClient.disconnect(self)\n\n\n\n\nDisconnect is a no-op with HTTP-only client, but the presence of this method makes it easy\nto switch between using HTTP \n MQTT client implementation", 
            "title": "HttpAbstractClient"
        }, 
        {
            "location": "/docs/message/", 
            "text": "Message\n\n\n\nMessage(self, data, timestamp=None)\n\n\n\n\nRepresents an abstract message recieved over Mqtt.  All implementations of\na Codec must return an object of this type.\n\n\nAttributes\n\n\n\n\ndata (dict)\n: The message payload\n\n\ntimestamp (datetime)\n: Timestamp intended to denote the time the message was sent,\n    or \nNone\n if this information is not available.", 
            "title": "Message"
        }, 
        {
            "location": "/docs/exceptions/connect/", 
            "text": "ConnectionException\n\n\n\nConnectionException(self, reason)\n\n\n\n\nGeneric Connection exception\n\n\nAttributes\n\n\n\n\nreason (string)\n: The reason why the connection exception occured", 
            "title": "ConnectionException"
        }, 
        {
            "location": "/docs/exceptions/config/", 
            "text": "ConfigurationException\n\n\n\nConfigurationException(self, reason)\n\n\n\n\nSpecific Connection exception where the configuration is invalid\n\n\nAttributes\n\n\n\n\nreason (string)\n: The reason why the configuration is invalid", 
            "title": "ConfigurationException"
        }, 
        {
            "location": "/docs/exceptions/auth/", 
            "text": "UnsupportedAuthenticationMethod\n\n\n\nUnsupportedAuthenticationMethod(self, method)\n\n\n\n\nSpecific Connection exception where the authentication method specified is not supported\n\n\nAttributes\n\n\n\n\nmethod (string)\n: The authentication method that is unsupported", 
            "title": "UnsupportedAuthenticationMethod"
        }, 
        {
            "location": "/docs/exceptions/invalidEvent/", 
            "text": "InvalidEventException\n\n\n\nInvalidEventException(self, reason)\n\n\n\n\nSpecific exception where an Event object can not be constructed\n\n\nAttributes\n\n\n\n\nreason (string)\n: The reason why the event could not be constructed", 
            "title": "InvalidEventException"
        }, 
        {
            "location": "/docs/exceptions/missingDecoder/", 
            "text": "MissingMessageDecoderException\n\n\n\nMissingMessageDecoderException(self, format)\n\n\n\n\nSpecific exception where there is no message decoder defined for the message format being processed\n\n\nAttributes\n\n\n\n\nformat (string)\n: The message format for which no encoder could be found", 
            "title": "MissingMessageDecoderException"
        }, 
        {
            "location": "/docs/exceptions/missingEncoder/", 
            "text": "MissingMessageEncoderException\n\n\n\nMissingMessageEncoderException(self, format)\n\n\n\n\nSpecific exception where there is no message encoder defined for the message format being processed\n\n\nAttributes\n\n\n\n\nformat (string)\n: The message format for which no encoder could be found", 
            "title": "MissingMessageEncoderException"
        }, 
        {
            "location": "/docs/exceptions/api/", 
            "text": "APIException\n\n\n\nAPIException(self, httpCode, message, response)\n\n\n\n\nException raised when any API call fails\n\n\nAttributes\n\n\n\n\nhttpCode (int)\n: The HTTP status code returned\n\n\nmessage (string)\n: The exception message\n\n\nresponse (string)\n: The reponse body that triggered the exception", 
            "title": "APIException"
        }, 
        {
            "location": "/docs/device/client/", 
            "text": "Client\n\n\n\nClient(self, options, logHandlers=None)\n\n\n\n\nExtends \nibmiotf.AbstractClient\n to implement a device client supporting\nmessaging over MQTT\n\n\nParameters\n\n\n\n\noptions (dict)\n: Configuration options for the client\n\n\nlogHandlers (list\n)\n: Log handlers to configure.  Defaults to \nNone\n,\n    which will result in a default log handler being created.\n\n\n\n\nConfiguration Options\n\n\nThe options parameter expects a Python dictionary containing the following keys:\n\n\n\n\norgId\n Your organization ID.\n\n\ntype\n The type of the device. Think of the device type is analagous to a model number.\n\n\nid\n A unique ID to identify a device. Think of the device id as analagous to a serial number.\n\n\nauth-method\n The method of authentication. The only method that is currently supported is \ntoken\n.\n\n\nauth-token\n An authentication token to securely connect your device to Watson IoT Platform.\n\n\nclean-session\n A boolean value indicating whether to use MQTT clean session.\n\n\n\n\nPublishing events\n\n\nEvents are the mechanism by which devices publish data to the Watson IoT Platform. The device\ncontrols the content of the event and assigns a name for each event that it sends.\n\n\nWhen an event is received by Watson IoT Platform, the credentials of the received event identify\nthe sending device, which means that a device cannot impersonate another device.\n\n\nEvents can be published with any of the three quality of service (QoS) levels that are defined\nby the MQTT protocol. By default, events are published with a QoS level of 0.\n\n\nclient.connect()\nqos=0\nmyData={'name' : 'foo', 'cpu' : 60, 'mem' : 50}\nclient.publishEvent(\nstatus\n, \njson\n, myData, qos)\n\n\n\n\nHandling commands\n\n\nWhen the device client connects, it automatically subscribes to any command that is specified for\nthis device. To process specific commands, you need to register a command callback method.\n\n\nThe messages are returned as an instance of the \nCommand\n class\n\n\ndef myCommandCallback(cmd):\n    print(\nCommand received: %s\n % cmd.data)\n    if cmd.command == \nsetInterval\n:\n        if 'interval' not in cmd.data:\n            print(\nError - command is missing required information: 'interval'\n)\n        else:\n            interval = cmd.data['interval']\n    elif cmd.command == \nprint\n:\n        if 'message' not in cmd.data:\n            print(\nError - command is missing required information: 'message'\n)\n        else:\n            print(cmd.data['message'])\nclient.connect()\nclient.commandCallback = myCommandCallback\n\n\n\n\nCustom message format support\n\n\nBy default, the message format is set to json, which means that the library supports the encoding\nand decoding of Python dictionary objects in JSON format. To add support for your own custom message formats,\nsee the Custom Message Format sample.\n\n\nWhen you create a custom encoder module, you must register it in the device client:\n\n\nimport myCustomCodec\n\nclient.setMessageEncoderModule(\ncustom\n, myCustomCodec)\nclient.publishEvent(\nstatus\n, \ncustom\n, myData)\n\n\n\n\nIf an event is sent in an unknown format or if a device does not recognize the format, the device\nlibrary raises \nibmiotf.MissingMessageDecoderException\n.\n\n\npublishEvent\n\n\n\nClient.publishEvent(self, event, msgFormat, data, qos=0, on_publish=None)\n\n\n\n\nPublish an event to Watson IoT Platform.\n\n\nParameters\n\n\n\n\nevent (string)\n: Name of this event\n\n\nmsgFormat (string)\n: Format of the data for this event\n\n\ndata (dict)\n: Data for this event\n\n\nqos (int)\n: MQTT quality of service level to use (\n0\n, \n1\n, or \n2\n)\n\n\non_publish(function)\n: A function that will be called when receipt\n   of the publication is confirmed.\n\n\n\n\nCallback and QoS\n\n\nThe use of the optional \non_publish\n function has different implications depending\non the level of qos used to publish the event:\n\n\n\n\nqos 0: the client has asynchronously begun to send the event\n\n\nqos 1 and 2: the client has confirmation of delivery from the platform", 
            "title": "Client"
        }, 
        {
            "location": "/docs/device/httpClient/", 
            "text": "HttpClient\n\n\n\nHttpClient(self, options, logHandlers=None)\n\n\n\n\nA basic device client with limited capabilies that forgoes\nan active MQTT connection to the service.  Extends \nibmiotf.HttpAbstractClient\n.\n\n\nParameters\n\n\n\n\noptions (dict)\n: Configuration options for the client\n\n\nlogHandlers (list\n)\n: Log handlers to configure.  Defaults to \nNone\n,\n    which will result in a default log handler being created.\n\n\n\n\nConfiguration Options\n\n\nThe options parameter expects a Python dictionary containing the following keys:\n\n\n\n\norgId\n Your organization ID.\n\n\ntype\n The type of the device. Think of the device type is analagous to a model number.\n\n\nid\n A unique ID to identify a device. Think of the device id as analagous to a serial number.\n\n\nauth-method\n The method of authentication. The only method that is currently supported is \ntoken\n.\n\n\nauth-token\n An authentication token to securely connect your device to Watson IoT Platform.\n\n\n\n\nThe HTTP client supports four content-types for posted events:\n\n\n\n\napplication/xml\n: for events/commands using message format \nxml\n\n\ntext/plain; charset=utf-8\n: for events/commands using message format \nplain\n\n\napplication/octet-stream\n: for events/commands using message format \nbin\n\n\napplication/json\n: the default for all other message formats.\n\n\n\n\npublishEvent\n\n\n\nHttpClient.publishEvent(self, event, msgFormat, data)\n\n\n\n\nPublish an event over HTTP(s) as given supported format\n\n\nRaises\n\n\n\n\nMissingMessageEncoderException\n: If there is no registered encoder for \nmsgFormat\n\n\nException\n: If something went wrong\n\n\n\n\nReturns\n\n\nint\n: The HTTP status code for the publish", 
            "title": "HttpClient"
        }, 
        {
            "location": "/docs/device/parseConfigFile/", 
            "text": "ParseConfigFile\n\n\n\nParseConfigFile(configFilePath)\n\n\n\n\nParse a configuration file into a Python dictionary suitable for passing to the\ndevice client constructor as the \noptions\n parameter\n\n\nNote: Support for this is likely to be removed in favour of\na yaml configuration configuration file as move towards the 1.0 release\n\n\nimport ibmiotf.device\n\ntry:\n    options = ibmiotf.device.ParseConfigFile(configFilePath)\n    client = ibmiotf.device.Client(options)\nexcept ibmiotf.ConnectionException  as e:\n    pass\n\n\n\n\n\nExample Configuration File\n\n\n[device]\norg=org1id\ntype=raspberry-pi-3\nid=00ef08ac05\nauth-method=token\nauth-token=Ab$76s)asj8_s5\nclean-session=true/false\ndomain=internetofthings.ibmcloud.com\nport=8883\n\n\n\n\nRequired Settings\n\n\n\n\norg\n\n\ntype\n\n\nid\n\n\nauth-method\n\n\nauth-token\n\n\n\n\nOptional Settings\n\n\n\n\nclean-session\n Defaults to \nfalse\n\n\ndomain\n Defaults to \ninternetofthings.ibmcloud.com\n\n\nport\n Defaults to \n8883", 
            "title": "ParseConfigFile"
        }, 
        {
            "location": "/docs/device/command/", 
            "text": "Command\n\n\n\nCommand(self, pahoMessage, messageEncoderModules)\n\n\n\n\nRepresents a command sent to a device.\n\n\nParameters\n\n\n\n\npahoMessage (?)\n: ?\n\n\nmessageEncoderModules (dict)\n: Dictionary of Python modules, keyed to the\n    message format the module should use.\n\n\n\n\nAttributes\n\n\n\n\ncommand (string)\n: Identifies the command.\n\n\nformat (string)\n: The format can be any string, for example JSON.\n\n\ndata (dict)\n: The data for the payload. Maximum length is 131072 bytes.\n\n\ntimestamp (datetime)\n: The date and time of the event.\n\n\n\n\nRaises\n\n\n\n\nInvalidEventException\n: If the command was recieved on a topic that does\n    not match the regular expression \niot-2/cmd/(.+)/fmt/(.+)", 
            "title": "Command"
        }, 
        {
            "location": "/docs/app/client/", 
            "text": "Client\n\n\n\nClient(self, options, logHandlers=None)\n\n\n\n\nExtends \nibmiotf.AbstractClient\n to implement an application client supporting\nmessaging over MQTT\n\n\nParameters\n\n\n\n\noptions (dict)\n: Configuration options for the client\n\n\nlogHandlers (list\n)\n: Log handlers to configure.  Defaults to \nNone\n,\n    which will result in a default log handler being created.\n\n\n\n\nConfiguration Options\n\n\nThe options parameter expects a Python dictionary containing the following keys:\n\n\n\n\nauth-key\n The API key to to securely connect your application to Watson IoT Platform.\n\n\nauth-token\n An authentication token to securely connect your application to Watson IoT Platform.\n\n\nclean-session\n A boolean value indicating whether to use MQTT clean session.\n\n\n\n\nsubscribeToDeviceCommands\n\n\n\nClient.subscribeToDeviceCommands(self, deviceType='+', deviceId='+', command='+', msgFormat='+')\n\n\n\n\nSubscribe to device command messages\n\n\nParameters\n\n\n\n\ndeviceType (string)\n: typeId for the subscription, optional.  Defaults to all device types (MQTT \n+\n wildcard)\n\n\ndeviceId (string)\n: deviceId for the subscription, optional.  Defaults to all devices (MQTT \n+\n wildcard)\n\n\ncommand (string)\n: commandId for the subscription, optional.  Defaults to all commands (MQTT \n+\n wildcard)\n\n\nmsgFormat (string)\n: msgFormat for the subscription, optional.  Defaults to all formats (MQTT \n+\n wildcard)\n\n\nqos (int)\n: MQTT quality of service level to use (\n0\n, \n1\n, or \n2\n)\n\n\n\n\nReturns\n\n\nint\n: If the subscription was successful then the return Message ID (mid) for the subscribe request\n    will be returned. The mid value can be used to track the subscribe request by checking against\n    the mid argument if you register a subscriptionCallback method.\n    If the subscription fails then the return value will be \n0\n\n\npublishCommand\n\n\n\nClient.publishCommand(self, deviceType, deviceId, command, msgFormat, data=None, qos=0, on_publish=None)\n\n\n\n\nPublish a command to a device\n\n\nParameters\n\n\n\n\ndeviceType (string) \n: The type of the device this command is to be published to\n\n\ndeviceId (string)\n: The id of the device this command is to be published to\n\n\ncommand (string) \n: The name of the command\n\n\nmsgFormat (string) \n: The format of the command payload\n\n\ndata (dict) \n: The command data\n\n\nqos (int) \n: The equivalent MQTT semantics of quality of service using the same constants (optional, defaults to \n0\n)\n\n\non_publish (function) \n: A function that will be called when receipt of the publication is confirmed.  This has\n\n\ndifferent implications depending on the qos\n:\n\n\n- qos 0 \n: the client has asynchronously begun to send the event\n\n\n- qos 1 and 2 \n: the client has confirmation of delivery from WIoTP\n\n\n\n\nsubscribeToDeviceStatus\n\n\n\nClient.subscribeToDeviceStatus(self, deviceType='+', deviceId='+')\n\n\n\n\nSubscribe to device status messages\n\n\nParameters\n\n\n\n\ndeviceType (string)\n: typeId for the subscription, optional.  Defaults to all device types (MQTT \n+\n wildcard)\n\n\ndeviceId (string)\n: deviceId for the subscription, optional.  Defaults to all devices (MQTT \n+\n wildcard)\n\n\n\n\nReturns\n\n\nint\n: If the subscription was successful then the return Message ID (mid) for the subscribe request\n    will be returned. The mid value can be used to track the subscribe request by checking against\n    the mid argument if you register a subscriptionCallback method.\n    If the subscription fails then the return value will be \n0\n\n\nsubscribeToDeviceEvents\n\n\n\nClient.subscribeToDeviceEvents(self, deviceType='+', deviceId='+', event='+', msgFormat='+', qos=0)\n\n\n\n\nSubscribe to device event messages\n\n\nParameters\n\n\n\n\ndeviceType (string)\n: typeId for the subscription, optional.  Defaults to all device types (MQTT \n+\n wildcard)\n\n\ndeviceId (string)\n: deviceId for the subscription, optional.  Defaults to all devices (MQTT \n+\n wildcard)\n\n\nevent (string)\n: eventId for the subscription, optional.  Defaults to all events (MQTT \n+\n wildcard)\n\n\nmsgFormat (string)\n: msgFormat for the subscription, optional.  Defaults to all formats (MQTT \n+\n wildcard)\n\n\nqos (int)\n: MQTT quality of service level to use (\n0\n, \n1\n, or \n2\n)\n\n\n\n\nReturns\n\n\nint\n: If the subscription was successful then the return Message ID (mid) for the subscribe request\n    will be returned. The mid value can be used to track the subscribe request by checking against\n    the mid argument if you register a subscriptionCallback method.\n    If the subscription fails then the return value will be \n0\n\n\npublishEvent\n\n\n\nClient.publishEvent(self, deviceType, deviceId, event, msgFormat, data, qos=0, on_publish=None)\n\n\n\n\nPublish an event on behalf of a device.\n\n\nParameters\n\n\n\n\ndeviceType (string)\n: The typeId of the device this event is to be published from\n\n\ndeviceId (string)\n: The deviceId of the device this event is to be published from\n\n\nevent (string)\n: The name of this event\n\n\nmsgFormat (string)\n: The format of the data for this event\n\n\ndata (dict) \n: The data for this event\n\n\nqos (int) \n: The equivalent MQTT semantics of quality of service using the same constants (optional, defaults to \n0\n)\n\n\non_publish (function) \n: A function that will be called when receipt of the publication is confirmed.  This\n\n\nhas different implications depending on the qos\n:\n\n\n- qos 0 \n: the client has asynchronously begun to send the event\n\n\n- qos 1 and 2 \n: the client has confirmation of delivery from IoTF", 
            "title": "Client"
        }
    ]
}